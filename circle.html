<canvas id="myCanvas" width="1000" height="1000" style="border:1px solid #000000;"></canvas>
<script src="JZZ.js"></script>
<script src="JZZ.synth.Tiny.js"></script>
<script>
    JZZ.synth.Tiny.register('Synth');
    var sound = JZZ().openMidiOut().or(function () { alert('Cannot open MIDI port!'); });

    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');
    const NOTES = ['D', 'e', 'E', 'F', 'g', 'G', 'a', 'A', 'b', 'B', 'C', 'd'];
    const MIDI_NOTES = ['D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'Db'];
    const CENTER_X = canvas.width / 2;
    const CENTER_Y = canvas.height / 2;
    const CIRCLE_DEPTH = 60;
    const NUM_OF_CIRCLES = 6;
    const NUM_OF_SECTORS = 12;
    const SEGMENT_WIDTH = 360 / NUM_OF_SECTORS;
    const HALF_SECTOR_ANGLE = SEGMENT_WIDTH / 2;
    var Chord = class {
        constructor(rootPosition, numNotes) {
            this.rootPosition = rootPosition;
            this.numNotes = numNotes;
        }
    }
    var Circle = class {
        constructor(id, name, color, startSector, startNote, noteScheme) {
            this.id = id;
            this.name = name
            this.color = color;
            this.startSector = startSector;
            this.startNote = startNote;
            this.noteScheme = noteScheme;
            this.chord = new Chord(0, 0);
        }

        incChordStartNote() {
            this.chord.rootPosition = this.getNextScalePosition();
        }
        decChordStartNote() {
            this.chord.rootPosition = this.getPrevScalePosition();
        }
        getChordNotes() {
            var notes = [];
            var position = this.chord.rootPosition;
            if (this.chord.numNotes > 0) {
                notes.push(position);
            }
            for (var i = 1; i < this.chord.numNotes; i++) {
                position = this.getNextChordPosition(position);
                notes.push(position);
            }
            return notes;
        }
        getNextChordPosition(position) {
            var firstPosition = this.getNextInterleavedScalePosition(position);
            return this.getNextInterleavedScalePosition(firstPosition);
        }
        getNextInterleavedScalePosition(position) {
            do {
                position++;
                if (position >= this.noteScheme.length) {
                    position = 0;
                }
            } while (this.noteScheme[position] == 0);
            return position;
        }
        getPrevChordPosition(position) {
            var firstPosition = this.getPrevInterleavedScalePosition(position);
            return this.getPrevInterleavedScalePosition(firstPosition);
        }

        getPrevInterleavedScalePosition(position) {
            do {
                position--;
                if (position < 0) {
                    position = this.noteScheme.length - 1;
                }
            } while (this.noteScheme[position] == 0);
            return position;
        }
        getNextScalePosition() {
            var i = this.chord.rootPosition;
            do {
                i++;
                if (i >= this.noteScheme.length) {
                    i = 0;
                }
            } while (this.noteScheme[i] == 0);
            return i;
        }
        getPrevScalePosition() {
            var i = this.chord.rootPosition;
            do {
                i--;
                if (i < 0) {
                    i = this.noteScheme.length - 1;
                }
            } while (this.noteScheme[i] == 0);
            return i;
        }
        getNumScaleNotes() {
            return this.noteScheme.filter(t => t == 1).length;
        }
        addChordNote() {
            if (this.chord.numNotes < this.getNumScaleNotes()) {
                this.chord.numNotes++;
            }
        }
        removeChordNote() {
            if (this.chord.numNotes > 0) {
                this.chord.numNotes--;
            }
        }

    }
    var circles = [
        new Circle(0, 'tones', 'Gold', 6, 0, [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]),
        new Circle(1, 'penta', 'YellowGreen', 6, 0, [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0]),
        new Circle(2, 'black', 'Black', 6, 0, [0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1]),
        new Circle(3, 'red', 'FireBrick', 6, 0, [1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1]),
        new Circle(4, 'blue', 'DodgerBlue', 6, 0, [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0]),
        new Circle(5, 'white', 'Linen', 6, 0, [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0]),
    ];
    var circleOrder = [0, 1, 2, 3, 4, 5];
    var selectedCircle = 5;
    var startAngle = 0 + HALF_SECTOR_ANGLE + 180;
    var endAngle = (SEGMENT_WIDTH + HALF_SECTOR_ANGLE) + 180;
    var startSector = 0;
    var startNote = 0;


    function refresh() {
        context.clearRect(0, 0, 1000, 1000);
        drawBackgroundCircle();
        for (var i = 0; i < NUM_OF_CIRCLES; i++) {
            drawCircle(i);
            drawNotes(i);
            drawChordNotes(i);
        }
        playClic();
    }

    function moveCircleIn() {
        moveCircle(selectedCircle, selectedCircle + 1);
    }
    function moveCircleOut() {
        moveCircle(selectedCircle, selectedCircle - 1);
    }
    function moveCircle(from, to) {
        if (to < 0) to = 5;
        if (to > 5) to = 0;
        var oldPosition = circleOrder[from];
        var newPosition = circleOrder[to];
        circleOrder[from] = newPosition;
        circleOrder[to] = oldPosition;
        selectedCircle = to;
    }
    function init() {
        document.addEventListener('keydown', (event) => {
            const keyName = event.key;
            if (event.ctrlKey) {
                if (keyName == 'ArrowLeft') {
                    decChordStartNote();
                } else if (keyName == 'ArrowRight') {
                    incChordStartNote();
                }
            } else if (event.shiftKey) {
                if (keyName == 'ArrowDown') {
                    moveCircleIn();
                } else if (keyName == 'ArrowUp') {
                    moveCircleOut();
                } else if (keyName == 'ArrowLeft') {
                    decCircleStartNote();
                } else if (keyName == 'ArrowRight') {
                    incCircleStartNote();
                }
            } else {
                if (keyName == ' ') {
                    playChord();
                } if (keyName == 'ArrowDown') {
                    selectNextCircle();
                } else if (keyName == 'ArrowUp') {
                    selectPrevCircle();
                } else if (keyName == 'ArrowLeft') {
                    decCircleStartSector();
                } else if (keyName == 'ArrowRight') {
                    incCircleStartSector();
                } else if (keyName == 'Home') {
                    resetStartSector();
                } else if (keyName == 'Insert') {
                    addChordNote();
                } else if (keyName == 'Delete') {
                    removeChordNote();
                }
            }
            refresh();
        });
        refresh();
    }
    function incChordStartNote() {
        getSelectedCircle().incChordStartNote();
    }
    function decChordStartNote() {
        getSelectedCircle().decChordStartNote();
    }

    function addChordNote() {
        getSelectedCircle().addChordNote();
    }

    function removeChordNote() {
        getSelectedCircle().removeChordNote();

    }
    function resetStartSector() {
        circles.forEach(t => t.startSector = 6);
    }
    function selectNextCircle() {
        selectedCircle++;
        selectedCircle %= 6;
    }
    function selectPrevCircle() {
        selectedCircle--;
        if (selectedCircle < 0) selectedCircle = 5;
    }
    function getSelectedCircle() {
        return circles[circleOrder[selectedCircle]];
    }
    function getCircle(numCircle) {
        return circles[circleOrder[numCircle]];
    }
    function decCircleStartSector() {
        getSelectedCircle().startSector--;
    }
    function incCircleStartSector() {
        getSelectedCircle().startSector++;
    }
    function decCircleStartNote() {
        getSelectedCircle().startNote--;
        if (getSelectedCircle().startNote < 0) {
            getSelectedCircle().startNote = 11;
        }
    }
    function incCircleStartNote() {
        getSelectedCircle().startNote++;
        if (getSelectedCircle().startNote > 11) {
            getSelectedCircle().startNote = 0;
        }
    }

    function drawNotes(numCircle) {
        var circle = getCircle(numCircle);
        var scheme = circle.noteScheme;
        var labelX = CENTER_X;
        var labelY = CENTER_Y;
        var angle = 360 / NUM_OF_SECTORS;
        for (var sector = 0; sector < NUM_OF_SECTORS; sector++) {
            labelX = CENTER_X + (CIRCLE_DEPTH * (numCircle + 1)) * Math.sin(angle * (circle.startSector + sector) * Math.PI / 180)
            labelY = CENTER_Y - (CIRCLE_DEPTH * (numCircle + 1)) * Math.cos(angle * (circle.startSector + sector) * Math.PI / 180)
            if (scheme[sector] == 1) {
                context.beginPath();
                context.arc(labelX, labelY, 12, 0, Math.PI * 2, false);
                context.fillStyle = 'White';
                context.fill();
                context.fillStyle = 'black';
                context.font = '15pt Calibri';
                var note = circle.startNote + sector;
                if (note > 11) note -= 12;
                if (note < 0) note += 12;
                context.fillText(NOTES[note], labelX - 5, labelY + 5);
            }
        }
    }

    function drawChordNotes(numCircle) {
        var circle = getCircle(numCircle);
        if (circle.chord.numNotes == 0) {
            return
        }
        notes = circle.getChordNotes();
        var scheme = circle.noteScheme;
        var labelX = CENTER_X;
        var labelY = CENTER_Y;
        var angle = 360 / NUM_OF_SECTORS;
        for (var note = 0; note < circle.chord.numNotes; note++) {
            labelX = CENTER_X + (CIRCLE_DEPTH * (numCircle + 1)) * Math.sin(angle * (circle.startSector + notes[note]) * Math.PI / 180)
            labelY = CENTER_Y - (CIRCLE_DEPTH * (numCircle + 1)) * Math.cos(angle * (circle.startSector + notes[note]) * Math.PI / 180)
            context.beginPath();
            context.arc(labelX, labelY, 5, 0, Math.PI * 2, true);
            if (note == 0) {
                context.strokeStyle = 'Red';
            } else {
                context.strokeStyle = 'Green';
            }
            context.stroke();
        }
    }
    function drawCircle(numCircle) {
        var circle = getCircle(numCircle);
        var radius = (1 + numCircle) * CIRCLE_DEPTH;
        context.strokeStyle = circle.color;
        for (var i = 0; i < NUM_OF_SECTORS; i++) {
            context.beginPath();
            context.arc(CENTER_X, CENTER_Y, radius, 0, Math.PI * 2, false);
            if (numCircle == selectedCircle) {
                context.lineWidth = CIRCLE_DEPTH;
                context.stroke();
            } else {
                context.lineWidth = 5;
                context.stroke();
            }
        }
    }

    function drawBackgroundCircle() {
        var radius = 7 * CIRCLE_DEPTH;
        context.fillStyle = 'Silver';
        context.beginPath();
        context.arc(CENTER_X, CENTER_Y, radius, 0, Math.PI * 2, true);
        context.lineWidth = CIRCLE_DEPTH;
        context.fill();
    }
    function playClic() {
        sound.noteOn(9, 80, 50)
            .wait(100)
            .noteOff(9, 80);
    }
    function playChord() {
        var notes = getSelectedCircle().getChordNotes();
        console.log(notes);
        var midiNotes = getMidiNotes(notes, getSelectedCircle().chord.rootPosition);
        midiNotes.forEach(note => {
            sound.noteOn(0, note, 50)
                .wait(100)
                .noteOff(0, note);
        });
    }
    function getMidiNotes(notes, startPosition) {
        var midiNotes = [];
        var lastNote = notes[0];
        var octave = 4;
        notes.forEach(note => {
            var octavedNote = startPosition + note;
            if(note >= 10){
                octave++;
            }
            if (octavedNote >= 12) {
                octavedNote = octavedNote % 12;
            }
            if(octavedNote < lastNote ){
                octave++;
            }
            lastNote = octavedNote;
            midiNotes.push(MIDI_NOTES[octavedNote] + octave  );
        });
        return midiNotes;
    }
    init();
</script>