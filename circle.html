<canvas id="myCanvas" width="1000" height="1000" style="border:1px solid #000000;"></canvas>
<script src="JZZ.js"></script>
<script src="JZZ.synth.Tiny.js"></script>
<script>
    JZZ.synth.Tiny.register('Synth');
    var sound = JZZ().openMidiOut().or(function () { alert('Cannot open MIDI port!'); });

    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');
    const NOTES = ['D', 'e', 'E', 'F', 'g', 'G', 'a', 'A', 'b', 'B', 'C', 'd'];
    const CENTER_X = canvas.width / 2;
    const CENTER_Y = canvas.height / 2;
    const CIRCLE_DEPTH = 60;
    const NUM_OF_CIRCLES = 6;
    const NUM_OF_SECTORS = 12;
    const SEGMENT_WIDTH = 360 / NUM_OF_SECTORS;
    const HALF_SECTOR_ANGLE = SEGMENT_WIDTH / 2;
    var Chord = class {
        constructor(rootPosition, numNotes) {
            this.rootPosition = rootPosition;
            this.numNotes = numNotes;
        }
    }
    var Circle = class {
        constructor(id, name, color, startSector, startNote, noteScheme) {
            this.id = id;
            this.name = name
            this.color = color;
            this.startSector = startSector;
            this.startNote = startNote;
            this.noteScheme = noteScheme;
            this.chord = new Chord(0, 0);
        }
    }
    var circles = [
        new Circle(0, 'tones', 'Gold', 6, 0, [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]),
        new Circle(1, 'penta', 'YellowGreen', 6, 0, [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0]),
        new Circle(2, 'black', 'Black', 6, 0, [0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1]),
        new Circle(3, 'red', 'FireBrick', 6, 0, [1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1]),
        new Circle(4, 'blue', 'DodgerBlue', 6, 0, [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0]),
        new Circle(5, 'white', 'Linen', 6, 0, [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0]),
    ];
    var circleOrder = [0, 1, 2, 3, 4, 5];
    var selectedCircle = 5;
    var startAngle = 0 + HALF_SECTOR_ANGLE + 180;
    var endAngle = (SEGMENT_WIDTH + HALF_SECTOR_ANGLE) + 180;
    var startSector = 0;
    var startNote = 0;

    function refresh() {
        context.clearRect(0, 0, 1000, 1000);
        drawBackgroundCircle();
        for (var i = 0; i < NUM_OF_CIRCLES; i++) {
            drawCircle(i);
            drawNotes(i);
        }
        playClic();
    }

    function moveCircleIn() {
        moveCircle(selectedCircle, selectedCircle + 1);
    }
    function moveCircleOut() {
        moveCircle(selectedCircle, selectedCircle - 1);
    }
    function moveCircle(from, to) {
        if (to < 0) to = 5;
        if (to > 5) to = 0;
        var oldPosition = circleOrder[from];
        var newPosition = circleOrder[to];
        circleOrder[from] = newPosition;
        circleOrder[to] = oldPosition;
        selectedCircle = to;

        //        console.log('order:' + circleOrder + ' selected circle:' + selectedCircle);
    }
    function init() {
        document.addEventListener('keydown', (event) => {
            const keyName = event.key;
            if (event.ctrlKey) {
                if (keyName == 'ArrowLeft') {
                    decChordStartNote();
                } else if (keyName == 'ArrowRight') {
                    incChordStartNote();
                }
            } else if (event.shiftKey) {
                if (keyName == 'ArrowDown') {
                    moveCircleIn();
                } else if (keyName == 'ArrowUp') {
                    moveCircleOut();
                } else if (keyName == 'ArrowLeft') {
                    decCircleStartNote();
                } else if (keyName == 'ArrowRight') {
                    incCircleStartNote();
                }
            } else {
                if (keyName == 'ArrowDown') {
                    selectNextCircle();
                } else if (keyName == 'ArrowUp') {
                    selectPrevCircle();
                } else if (keyName == 'ArrowLeft') {
                    decCircleStartSector();
                } else if (keyName == 'ArrowRight') {
                    incCircleStartSector();
                } else if (keyName == 'Home') {
                    resetStartSector();
                } else if (keyName == 'Insert') {
                    addChordNote();
                } else if (keyName == 'Delete') {
                    removeChordNote();
                }

            }

            refresh();
        });
        refresh();
    }
    function addChordNote(){

    }
    function removeChordNote(){

    }
    function resetStartSector() {
        circles.forEach(t => t.startSector = 6);
    }
    function selectNextCircle() {
        selectedCircle++;
        selectedCircle %= 6;
    }
    function selectPrevCircle() {
        selectedCircle--;
        if (selectedCircle < 0) selectedCircle = 5;
    }
    function decCircleStartSector() {
        circles[circleOrder[selectedCircle]].startSector--;
    }
    function incCircleStartSector() {
        circles[circleOrder[selectedCircle]].startSector++;
    }
    function decCircleStartNote() {
        circles[circleOrder[selectedCircle]].startNote--;
        if (circles[circleOrder[selectedCircle]].startNote < 0) {
            circles[circleOrder[selectedCircle]].startNote = 11;
        }
    }
    function incCircleStartNote() {
        circles[circleOrder[selectedCircle]].startNote++;
        if (circles[circleOrder[selectedCircle]].startNote > 11) {
            circles[circleOrder[selectedCircle]].startNote = 0;
        }
    }

    function drawNotes(numCircle) {
        var circle = circles[circleOrder[numCircle]];
        var scheme = circle.noteScheme;
        var labelX = CENTER_X;
        var labelY = CENTER_Y;
        var angle = 360 / NUM_OF_SECTORS;
        for (var sector = 0; sector < NUM_OF_SECTORS; sector++) {
            labelX = CENTER_X + (CIRCLE_DEPTH * (numCircle + 1)) * Math.sin(angle * (circle.startSector + sector) * Math.PI / 180)
            labelY = CENTER_Y - (CIRCLE_DEPTH * (numCircle + 1)) * Math.cos(angle * (circle.startSector + sector) * Math.PI / 180)
            if (scheme[sector] == 1) {
                context.beginPath();
                context.arc(labelX, labelY, 12, 0, Math.PI * 2, false);
                context.fillStyle = 'White';
                context.fill();
                context.fillStyle = 'black';
                context.font = '15pt Calibri';
                var note = circle.startNote + sector;
                if (note > 11) note -= 12;
                if (note < 0) note += 12;
                context.fillText(NOTES[note], labelX - 5, labelY + 5);
            }
        }
    }


    function drawCircle(numCircle) {
        var circle = circles[circleOrder[numCircle]];
        var radius = (1 + numCircle) * CIRCLE_DEPTH;
        context.strokeStyle = circle.color;
        for (var i = 0; i < NUM_OF_SECTORS; i++) {
            context.beginPath();
            context.arc(CENTER_X, CENTER_Y, radius, 0, Math.PI * 2, false);
            if (numCircle == selectedCircle) {
                context.lineWidth = CIRCLE_DEPTH;
                context.stroke();
            } else {
                context.lineWidth = 5;
                context.stroke();
            }
        }
    }

    function drawBackgroundCircle() {
        var radius = 7 * CIRCLE_DEPTH;
        context.fillStyle = 'Silver';
        context.beginPath();
        context.arc(CENTER_X, CENTER_Y, radius, 0, Math.PI * 2, true);
        context.lineWidth = CIRCLE_DEPTH;
        context.fill();
    }
    function playClic() {
        sound.noteOn(9, 80, 50)
            .wait(100)
            .noteOff(9, 80);
    }
    init();
</script>